## Provides convenient (de)serialization functionality going to and from JSON/Dicts <-> Godot Resource
## This makes it useful for storing both configuration and save data
## while remaining compatible with Godot's more complex types (Vectors, Colors, Typed Arrays, RNG)
## All data container objects should inherit from this or PrototypeData
## NOTE: Typically use SerializeableData for readonly data with object_id as a unique identifier
## NOTE: For making many objects created via prototyping from a readonly template, extend from PrototypeData subclass instead
## NOTE: Only properties with @export will be saved/loaded
extends Resource
class_name SerializableData


#region Recursive Property Script Cache

## Generated by build_serializable_script_cache()
static var _serializable_data_script_cache: Dictionary[String, Script] = {
	#"class_name": SerializableData
}

## This is an internal cache built across ALL objects which inherit from SerializableData.
## Maps class_name to the list of @export properties which contain a SerializableData, and
## the SerializableData Script to use to instantiate it. This is used by _get_recursive_properties().
static var _recursive_property_script_cache: Dictionary[String, Dictionary] = {
	 #"class_name": {
		#"property_name": SerializableData
	#}
}

## NOTE: This method is called from Global.build_schema() once at runtime.
## Creates a mapping of global class names to the Script object of that class. This is used to
## build the _serializable_data_script_cache cache which is used to build
## the _recursive_property_script_cache cache.
static func build_serializable_script_cache() -> void:
	var global_class_list: Array = ProjectSettings.get_global_class_list()
	for class_data: Dictionary in global_class_list:
		var base_class_str: String = class_data["base"]
		var class_str: String = class_data["class"]
		var class_script_path: String = class_data["path"]
		if base_class_str == "SerializableData" or base_class_str == "PrototypeData":
			var script: Script = load(class_script_path)
			_serializable_data_script_cache[class_str] = script

## Builds a cache mapping a class name to a dictionary of exported
## recursive(extends from SerializableData/PrototypeData) property names to the
## Script Resource used to instantiate them. This is generated the first time an instance
## of each SerializableData type runs _get_recursive_properties()
func build_recursive_property_script_cache() -> void:
	var property_name_to_script: Dictionary[String, Script] = {}
	
	var script := get_script() as Script
	var global_name: String = script.get_global_name()
	
	# iterate over exported properties
	for property_data: Dictionary in script.get_script_property_list():
		var property_name = property_data["name"]
		var usage: int = property_data["usage"]
		var is_exported: bool = (usage & PROPERTY_USAGE_STORAGE) == PROPERTY_USAGE_STORAGE
		if is_exported:
			# get the type of property and use it to determine how to get Script Resource
			var type: int = property_data["type"]
			match type:
				TYPE_OBJECT:
					# get class (if any) of the property
					var property_class_name: String = property_data["class_name"]
					# make sure it's a SerializableData
					if _serializable_data_script_cache.has(property_class_name):
						property_name_to_script[property_name] = _serializable_data_script_cache[property_class_name]
				TYPE_ARRAY:
					# get script type of Array
					var property_value = get(property_name)
					var property_value_script: Script = property_value.get_typed_script()
					if property_value_script != null:
						var script_global_name: String = property_value_script.get_global_name()
						# make sure it's a SerializableData
						if _serializable_data_script_cache.has(script_global_name):
							property_name_to_script[property_name] = property_value_script
				TYPE_DICTIONARY:
					# get the script type of the Dictionary's value
					var property_value = get(property_name)
					var property_value_script: Script = property_value.get_typed_value_script()
					if property_value_script != null:
						var script_global_name: String = property_value_script.get_global_name()
						# make sure it's a SerializableData
						if _serializable_data_script_cache.has(script_global_name):
							property_name_to_script[property_name] = property_value_script
	# cache results
	_recursive_property_script_cache[global_name] = property_name_to_script

## Returns a dictionary mapping exportable property_names of containers(arrays and dicts) and
## SerializableData type fields embedded recursively in this object to the SerializableData class of the
## type they match.
## Dictionaries should always use Object UID keys and PrototypeData Script values
func _get_recursive_properties() -> Dictionary:
	# get the name of the class from its script
	var script := get_script() as Script
	var global_name: String = script.get_global_name()
	# build property cache if it doesn't exist
	if not _recursive_property_script_cache.has(global_name):
		build_recursive_property_script_cache()
	# get properties from cache
	return _recursive_property_script_cache.get(global_name, {})
#endregion


## Identifies this subtype of object. This should be manually assigned and given a human readable name
## Follows format of "nountype_subtypename" eg "level_volcano" for an instance of LevelData
## NOTE: PrototypeData subclass is used if you want multiple objects of the same subtype (multiple enemy_elite_zombies)
@export var object_id: String = "" 

func _init(_object_id: String = "") -> void:
	if _object_id != "":
		object_id = _object_id

func get_serializable_property_names() -> Array[String]:
	# gets all variables with @export tag
	var result: Array[String] = []
	var script := get_script() as Script
	for property in script.get_script_property_list():
		var usage: int = property["usage"]
		var is_exported: bool = (usage & PROPERTY_USAGE_STORAGE) == PROPERTY_USAGE_STORAGE
		if is_exported:
			result.append(property["name"])
	
	return result

## Used for exporting a file to a formatted external json file used in the framework
func get_serializable_properties_to_json_patch() -> Dictionary:
	return {
		"properties": get_serializable_properties(true), # the properties
		"patch_data": {} # how to handle merging the properties
	}

## Gets a Dictionary[String, Variant] representing this object, containing all variables with @export tag
## and their (optionally json friendly) values.
func get_serializable_properties(json_friendly: bool = true) -> Dictionary:
	var result: Dictionary = {} # returned representation of the object
	var script := get_script() as Script
	var recursive_properties: Dictionary = _get_recursive_properties()
	var native_properties: Dictionary = _get_native_properties()
	
	# iterate over all @export properties
	for property in script.get_script_property_list():
		var usage: int = property["usage"]
		var is_exported: bool = (usage & PROPERTY_USAGE_STORAGE) == PROPERTY_USAGE_STORAGE
		if is_exported:
			# get property name and its corresponding value
			var property_name: String = property["name"]
			var value: Variant = get(property_name)
			
			# write the read value to the output
			result[property_name] = value
			
			# json_friendly requires packing child SerializableData objects and godot native
			# objects into a json style
			if json_friendly:
				# pack recursive objects
				if recursive_properties.has(property_name):
					# array of packed objects
					if value is Array:
						var packed_array: Array = []
						for data_object: SerializableData in value:
							var packed_data: Dictionary = data_object.get_serializable_properties(true) 
							packed_array.append(packed_data)
						result[property_name] = packed_array
					elif value is Dictionary:
						# dictionary of packed objects
						var packed_dictionary = {}
						
						# Dictionary[String, SerializableData]
						for id: String in value.keys():
							var data_object: Variant = value[id]
							var packed_data: Dictionary = data_object.get_serializable_properties(true) 
							packed_dictionary[id] = packed_data

						result[property_name] = packed_dictionary
					else:
						# assume single type field
						if value == null:
							result[property_name] = null
						else:
							var data_object: SerializableData = value
							result[property_name] = data_object.get_serializable_properties(true) 
					continue
				
				# pack native godot object collections
				elif native_properties.has(property_name):
					var type_hint_value: Variant = native_properties[property_name]
					if value is Dictionary:
						var json_friendly_dict: Dictionary = native_dict_to_json_friendly(type_hint_value, value)
						result[property_name] = json_friendly_dict
					elif value is Array:
						var json_friendly_array: Array = native_array_to_json_friendly(type_hint_value, value)
						result[property_name] = json_friendly_array
					else:
						var json_friendly_value: Variant = native_object_to_json_friendly(value)
						result[property_name] = json_friendly_value
	
	return result

## utility function to get the object_id from a formatted external json file.
## This is primarily used to check if an object already exists so it can be patched over
static func get_object_id_from_json_patch(json_patch: Dictionary) -> String:
	var properties: Dictionary = json_patch.get("properties", {})
	return properties.get("object_id", "")


## Wrapper for set_serializable_properties() that uses the export format for patches.
func set_serializable_properties_from_json_patch(json_patch: Dictionary) -> void:
	var properties: Dictionary = json_patch.get("properties", {})
	var patch_data: Dictionary = json_patch.get("patch_data", {})
	set_serializable_properties(properties, true, patch_data)
	

## Takes a Dictionary[String, Variant] representation of an object obtained by get_serializable_properties()
## and overwrites this object with those properties.
## json_friendly will convert fields from json friendly types back into godot native or
## SerializableData versions.
## merge_strategy maps a property to the way that property should be treated. This allows for more complex
## things like adjusting arrays/dicts, or addition to numbers/vectors. If a property name is not listed
## it will use a simple overwrite for that property.
func set_serializable_properties(object_data: Dictionary, json_friendly: bool = true, patch_data: Dictionary = {}) -> void:
	var recursive_properties: Dictionary = _get_recursive_properties()
	var native_properties: Dictionary = _get_native_properties()
	for property_name in object_data:
		var current_value: Variant = get(property_name)
		var new_value: Variant = object_data.get(property_name, null)
		var property_patch_strategy: String = patch_data.get(property_name, "overwrite")
		
		if not json_friendly:
			if current_value is Dictionary and new_value is Dictionary:
				set(property_name, patch_dictionary(current_value, new_value, property_patch_strategy))
			elif current_value is Array and new_value is Array:
				set(property_name, patch_array(current_value, new_value, property_patch_strategy))
			else:
				set(property_name, new_value) # directly overwrite the field with no conversions
		else:
			### recursive embedded objects need to be unpacked from json
			if recursive_properties.has(property_name):
				### figure out if value is Array[SerializeableData], Dictionary[String, SerializeableData], or SerializeableData
				var recursive_type = recursive_properties[property_name] # get the type of the object to make
				if current_value is Array:
					# Array[SerializableData]
					# populate the new array from json dictionary payloads
					var unpacked_array: Array = []
					for data: Dictionary in new_value:
						var serializeable_data: SerializableData = recursive_type.new()
						serializeable_data.set_serializable_properties(data)
						unpacked_array.append(serializeable_data)
					
					# godot typed array weirdness; requires copying an existing typed array
					# then mutating it with new values
					var temp_value = get(property_name)
					temp_value.clear()
					temp_value.assign(unpacked_array)
					
					set(property_name, temp_value)
					
					continue
				elif current_value is Dictionary:
					# Dictionary[String, SerializableData]
					var unpacked_dictionary: Dictionary = {}
					for id: String in new_value.keys():
						var data: Dictionary = new_value[id]
						var serializeable_data: SerializableData = recursive_type.new()
						serializeable_data.set_serializable_properties(data)
						unpacked_dictionary[id] = serializeable_data
					
					# godot typed dicts weirdness; requires copying an existing typed dict
					# then mutating it with new values
					var temp_value = get(property_name)
					temp_value.clear()
					temp_value.assign(unpacked_dictionary)
					set(property_name, temp_value)
					continue
				else:
					# assume single type field of SerializableData
					if new_value == null:
						set(property_name, null) # overwrite this field into null
					elif new_value is Dictionary:
						# unpack dictionary as an object
						var serializeable_data: SerializableData = recursive_type.new()
						serializeable_data.set_serializable_properties(new_value)
						set(property_name, serializeable_data)
					else:
						push_error("No dictionary detected for unpacking in field ", property_name)
				
				continue
			### convert to native godot object collections from json
			elif native_properties.has(property_name):
				# use a temporary object instance to determine (sub) type of the field
				var type_hint_value: Variant = native_properties[property_name]
				if current_value is Dictionary:
					var temp_value = get(property_name)
					temp_value.clear()
					
					var json_friendly_dict = json_friendly_to_native_dict(type_hint_value, new_value)
					temp_value.assign(json_friendly_dict)
					set(property_name, temp_value)
					continue
				elif current_value is Array:
					# attempts to preserve type from original property for typed array compatibility
					var temp_value = get(property_name)
					temp_value.clear()
					
					var json_friendly_array = json_friendly_to_native_array(type_hint_value, new_value)
					temp_value.assign(json_friendly_array)
					set(property_name, temp_value)
					continue
				else:
					var json_friendly_value: Variant = json_friendly_to_native_object(type_hint_value, new_value)
					set(property_name, json_friendly_value)
					continue
			### normal typed values need no conversion
			else:
				if current_value is Dictionary:
					# assign for typed dict safety
					var temp_value = get(property_name).duplicate()
					temp_value.clear()
					temp_value.assign(new_value)
					var patched_dictionary = patch_dictionary(current_value, temp_value, property_patch_strategy)
					set(property_name, temp_value)
				elif current_value is Array:
					# assign for typed array safety
					var temp_value = get(property_name).duplicate()
					temp_value.clear()
					temp_value.assign(new_value)
					var patched_array = patch_array(current_value, temp_value, property_patch_strategy)
					set(property_name, patched_array)
				else:
					set(property_name, new_value)



## Using a type hint derived from _get_native_properties(), converts a Dictonary[String, Variant]
## of godot native types into a json friendly dict.
static func native_dict_to_json_friendly(type_hint_value: Variant, value: Dictionary) -> Dictionary:
	var json_friendly_dict: Dictionary = {}
	
	if type_hint_value is Vector2:
		for key_name: String in value.keys():
			var vect2: Vector2 = value[key_name]
			json_friendly_dict[key_name] = [vect2.x, vect2.y]
		return json_friendly_dict
	if type_hint_value is Vector2i:
		for key_name: String in value.keys():
			var vect2: Vector2i = value[key_name]
			json_friendly_dict[key_name] = [vect2.x, vect2.y]
		return json_friendly_dict
	if type_hint_value is Vector3:
		for key_name: String in value.keys():
			var vect3: Vector3 = value[key_name]
			json_friendly_dict[key_name] = [vect3.x, vect3.y, vect3.z]
		return json_friendly_dict
	if type_hint_value is Vector3i:
		for key_name: String in value.keys():
			var vect3: Vector3i = value[key_name]
			json_friendly_dict[key_name] = [vect3.x, vect3.y, vect3.z]
		return json_friendly_dict
	if type_hint_value is RandomNumberGenerator:
		for key_name: String in value.keys():
			var rng: RandomNumberGenerator = value[key_name]
			var rng_seed: int = rng.seed
			var rng_state: int = rng.state
			# json does not play nicely with large ints in RandomNumberGenerator, convert to strings before serializing
			var rng_seed_str: String = str(rng_seed)
			var rng_state_str: String = str(rng_state)
			json_friendly_dict[key_name] = [rng_seed_str, rng_state_str]
		return json_friendly_dict
	
	return value

static func native_array_to_json_friendly(type_hint_value: Variant, value: Array) -> Array:
	var json_friendly_array: Array = []
	if value is Array[Vector2]:
		for vect2: Vector2 in value:
			json_friendly_array.append([vect2.x, vect2.y])
		return json_friendly_array
	elif value is Array[Vector2i]:
		for vect2: Vector2i in value:
			json_friendly_array.append([vect2.x, vect2.y])
		return json_friendly_array
	elif value is Array[Vector3]:
		for vect3: Vector3 in value:
			json_friendly_array.append([vect3.x, vect3.y, vect3.z])
		return json_friendly_array
	elif value is Array[Vector3i]:
		for vect3: Vector3i in value:
			json_friendly_array.append([vect3.x, vect3.y, vect3.z])
		return json_friendly_array
	
	return value

## Converts a native godot object to a compact json friendly version
static func native_object_to_json_friendly(value: Variant) -> Variant:
	if value is Color:
		return value.to_html(true) # convert colors to strings for serialization
	elif value is Vector2:
		return [value[0], value[1]]
	elif value is Vector2i:
		return [value[0], value[1]]
	elif value is Vector3:
		return [value[0], value[1], value[2]]
	elif value is Vector3i:
		return [value[0], value[1], value[2]]
	elif value is RandomNumberGenerator:
		# json does not play nicely with large ints in RandomNumberGenerator, convert to strings before serializing
		return [str(value.seed), str(value.state)]
	return value


static func json_friendly_to_native_dict(type_hint_value: Variant, json_friendly_values: Dictionary) -> Dictionary:
	var json_friendly_dict: Dictionary = {}
	
	if type_hint_value is Vector2:
		for key_name: String in json_friendly_values.keys():
			var json_friendly_value = json_friendly_values[key_name]
			
			var vect_x: int = json_friendly_value[0]
			var vect_y: int = json_friendly_value[1]
			var vect2: Vector2 = Vector2(vect_x, vect_y)
			
			json_friendly_dict[key_name] = vect2
		
		return json_friendly_dict
	if type_hint_value is Vector2i:
		for key_name: String in json_friendly_values.keys():
			var json_friendly_value = json_friendly_values[key_name]
			
			var vect_x: int = json_friendly_value[0]
			var vect_y: int = json_friendly_value[1]
			var vect2: Vector2i = Vector2i(vect_x, vect_y)
			
			json_friendly_dict[key_name] = vect2
		
		return json_friendly_dict
	if type_hint_value is Vector3:
		for key_name: String in json_friendly_values.keys():
			var json_friendly_value = json_friendly_values[key_name]
			
			var vect_x: int = json_friendly_value[0]
			var vect_y: int = json_friendly_value[1]
			var vect_z: int = json_friendly_value[3]
			var vect3: Vector3 = Vector3(vect_x, vect_y, vect_z)
			
			json_friendly_dict[key_name] = vect3
		
		return json_friendly_dict
	if type_hint_value is Vector3i:
		for key_name: String in json_friendly_values.keys():
			var json_friendly_value = json_friendly_values[key_name]
			
			var vect_x: int = json_friendly_value[0]
			var vect_y: int = json_friendly_value[1]
			var vect_z: int = json_friendly_value[3]
			var vect3: Vector3i = Vector3i(vect_x, vect_y, vect_z)
			
			json_friendly_dict[key_name] = vect3
		
		return json_friendly_dict
	if type_hint_value is RandomNumberGenerator:
		for key_name: String in json_friendly_values.keys():
			var json_friendly_value = json_friendly_values[key_name]
			# json does not play nicely with large ints in RandomNumberGenerator, convert from stored strings
			var rng_seed: int = int(json_friendly_value[0])
			var rng_state: int = int(json_friendly_value[1])
			var rng: RandomNumberGenerator = RandomNumberGenerator.new()
			rng.seed = rng_seed
			rng.state = rng_state
			json_friendly_dict[key_name] = rng
			
		return json_friendly_dict
	
	return json_friendly_values # return existing dict

static func json_friendly_to_native_array(type_hint_value: Variant, json_value: Array) -> Array:
	return []

## Converts a json friendly object back to its original state, using the property to determine type.
## If called using json_friendly_to_native_collection for sub fields, a dummy value will be passed in
## to type_hint_value instead of the property
static func json_friendly_to_native_object(type_hint_value: Variant, json_friendly_value: Variant) -> Variant:
	if type_hint_value is Color and json_friendly_value is String: 
		var color: Color = Color.from_string(json_friendly_value, Color.WHITE) # corresponding property is a color, will be converted from a serialized string to a color
		return color
	elif json_friendly_value is Array:
		# Vector2
		if type_hint_value is Vector2i:
			if len(json_friendly_value) >= 2:
				var vect2: Vector2i = Vector2i(int(json_friendly_value[0]), int(json_friendly_value[1]))
				return vect2
		elif type_hint_value is Vector2:
			if len(json_friendly_value) >= 2:
				var vect2: Vector2 = Vector2(json_friendly_value[0], json_friendly_value[1])
				return vect2
		# Vector3
		elif type_hint_value is Vector3i:
			if len(json_friendly_value) >= 3:
				var vect3: Vector3i = Vector3i(int(json_friendly_value[0]), int(json_friendly_value[1]), int(json_friendly_value[2]))
				return vect3
		elif type_hint_value is Vector3:
			if len(json_friendly_value) >= 3:
				var vect3: Vector3 = Vector3(json_friendly_value[0], json_friendly_value[1], json_friendly_value[2])
				return vect3
		# RandomNumberGenerator
		elif type_hint_value is RandomNumberGenerator:
			if len(json_friendly_value) >= 2:
				# json does not play nicely with large ints in RandomNumberGenerator, convert from stored strings
				var rng_seed: int = int(json_friendly_value[0])
				var rng_state: int = int(json_friendly_value[1])
				var rng: RandomNumberGenerator = RandomNumberGenerator.new()
				rng.seed = rng_seed
				rng.state = rng_state
				return rng
	
	return json_friendly_value # assumed to already be json friendly

#region Patching Methods
static func patch_dictionary(dict_1: Dictionary, dict_2: Dictionary, patch_strategy: String) -> Dictionary:
	var returned_dict: Dictionary = dict_1.duplicate()
	match patch_strategy:
		"merge_overwrite":
			returned_dict.merge(dict_2, true)
		"merge_keep":
			returned_dict.merge(dict_2, false)
		"erase":
			for item: Variant in dict_2.keys():
				returned_dict.erase(item)
		"overwrite", _:
			returned_dict.clear()
			returned_dict.assign(dict_2) 
	return returned_dict


static func patch_array(array_1: Array, array_2: Array, patch_strategy: String) -> Array:
	var returned_array: Array = array_1.duplicate()
	match patch_strategy:
		"append":
			returned_array += array_2
		"append_uniques":
			for item: Variant in array_2:
				if not array_1.has(item):
					returned_array.append(item)
		"erase":
			# remove all items listed from first array
			for item: Variant in array_2:
				returned_array.erase(item)
		"overwrite", _:
			returned_array.clear()
			returned_array.assign(array_2)
	return returned_array

#endregion


## Maps a property name to an instance of the type of native godot object that it composes
## Used for exported properties of Object, Array[Object], and Dictionary[String, Object]
## NOTE: The property name must map to an instance of the native type, not the class/type.
## RandomNumberGenerator.new() or Vector2() will work, but not RandomNumberGenerator or Vector2
func _get_native_properties() -> Dictionary:
	return {
		#"property_name_1": RandomNumberGenerator.new(),
		#"property_name_2": Vector2(),
		#"property_name_3": Vector3(),
		#"property_name_4": Color(),
	}
